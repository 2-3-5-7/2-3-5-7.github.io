{
    "version": "https://jsonfeed.org/version/1",
    "title": "自强不息 厚德载物 • All posts by \"专业\" category",
    "description": "分享各种内容，方便自己与他人查阅，欢迎评论",
    "home_page_url": "https://2-3-5-7.github.io",
    "items": [
        {
            "id": "https://2-3-5-7.github.io/%E4%B8%93%E4%B8%9A/OOC/",
            "url": "https://2-3-5-7.github.io/%E4%B8%93%E4%B8%9A/OOC/",
            "title": "OOC",
            "date_published": "1970-01-01T00:00:00.000Z",
            "content_html": "<p><a href=\"https://lwn.net/Articles/444910/\">Object-oriented design patterns in the kernel 1，多态部分</a><br><a href=\"https://lwn.net/Articles/446317/\">Object-oriented design patterns in the kernel 2，继承部分</a></p>\n<p><strong>下载保存</strong></p>\n<p><a href=\"https://www.cs.princeton.edu/courses/archive/spring21/cos217/\">https://www.cs.princeton.edu/courses/archive/spring21/cos217/</a><br><a href=\"https://www.cs.princeton.edu/courses/archive/spring21/cos217/lectures/\">https://www.cs.princeton.edu/courses/archive/spring21/cos217/lectures/</a></p>\n<h1 id=\"1-封装\"><a href=\"#1-封装\" class=\"headerlink\" title=\"1 封装\"></a>1 封装</h1><ul>\n<li>参考文件操作 FILE*</li>\n<li>使用不完全类型</li>\n<li>头文件分成 2 个，一个对外接口，一个用来给子类嵌套继承</li>\n</ul>\n<h1 id=\"2-多态\"><a href=\"#2-多态\" class=\"headerlink\" title=\"2 多态\"></a>2 多态</h1><p>两种实现方式，常用第 2 种，文章对内核种第 2 种使用的特殊情况做了讨论</p>\n<ol>\n<li>最简单的方法是结构体包含函数指针，函数第一个参数为结构体指针。bar-&gt;foo(bar, …args)。但在对象很多时由于内存占用比下面的 vtable 多，这种 linux 内核不常用</li>\n<li>再复杂是将函数指针组成表，virtual function table (vtable) ，一般命名为 XXX_operations、XXX_ops，对象中包含这个表的指针<ul>\n<li>vtable 为 NULL 的 2 个原因<ol>\n<li>新添加了一个方法，但还没实现</li>\n<li>该方法对这种情况无意义，临时的或长期的</li>\n</ol>\n<ul>\n<li>但作者认为总可避免使用 NULL（个人观点：会掩盖 Bug）<ul>\n<li>NULL 是少数时，实现默认方法，利用 C99 多次初始化，将默认值写在前面</li>\n<li>NULL 是多数时，且性能很重要，在调用前判断 flag 的 bit，出现特殊情况才调 vtable 中的函数</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>vtable 还可包含模块名称和链表 struct list_head，便于上层查找注册的设备</li>\n<li>vtable 第一个参数不是结构体指针的情况<ul>\n<li>结构体指针放在了最后一个参数</li>\n<li>只有一个对象，所以不需要指针，这个对象就是全局的</li>\n<li>多重继承，<a href=\"https://www.liaoxuefeng.com/wiki/1016959663602400/1017502939956896\">Mixin</a>，提供某个功能，但不以这个对象为主，需要多个对象</li>\n<li>子类的操作放入父类的 vtable 中，避免数量多的结构体过大，节省内存，以 struct page 举例</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h1 id=\"3-继承-is\"><a href=\"#3-继承-is\" class=\"headerlink\" title=\"3 继承 is\"></a>3 继承 is</h1><table>\n<thead>\n<tr>\n<th></th>\n<th>派生类包含基类</th>\n<th>基类使用 <code>void *private</code> 指针</th>\n<th>基类包含派生类</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>定义</td>\n<td>基类是第一个派生类成员</td>\n<td>基类和派生类互相指</td>\n<td>基类和派生类定义到一个文件<br />派生成员 union 实现<br />把每个使用 union 的地方看作继承</td>\n</tr>\n<tr>\n<td>创建</td>\n<td>调派生类 ctor，派生类 ctor 再调基类 ctor</td>\n<td>先调基类 ctor，基类 ctor 再调派生类 ctor</td>\n<td>先调基类 ctor，再调派生类 ctor</td>\n</tr>\n<tr>\n<td>使用</td>\n<td>对外提供基类指针，用多态方式调派生类接口<br />派生类接口中用 container_of() 将基类指针转成派生类</td>\n<td>&#x2F;</td>\n<td>&#x2F;</td>\n</tr>\n<tr>\n<td>优点</td>\n<td>多数情况</td>\n<td>适用于需要切换子类的类型时</td>\n<td>&#x2F;</td>\n</tr>\n<tr>\n<td>缺点</td>\n<td>&#x2F;</td>\n<td>两次内存分配<br />性能不好，内存占用和解引用花费时间<br />void * 可读性差，看不出含义</td>\n<td>浪费内存</td>\n</tr>\n</tbody></table>\n<ul>\n<li><p>mixin 类型继承，例如链表，提供某种服务</p>\n</li>\n<li><p>一个对象只有一个引用计数（在最内层基类中）管理生命周期，内核不使用垃圾回收，因此可用是否有引用计数将单继承与 mixin 继承区分开</p>\n</li>\n<li><p>TODO，下一步看 linux 内核加密部分、openssl 部分代码，复习 ooc 代码，仿写出 modbus 代码</p>\n</li>\n<li><p>重点在第 6 章，后续章要么太难，要么与主题无关，所以基本没看。此外那个计算器是个有趣、有难度的例子。这本书使用 void* 而没用不完全类型（即前向声明）是个小瑕疵，否则代码会更清晰</p>\n</li>\n<li><p>添加新函数时，基于 vtable 基类 Class 扩展新的函数，定义好后，new 一个新的 vtable 对象（这其实分两步，见第 6 章 initPoint() 代码），所谓类描述符。<br>添加新成员时，基于 Object 扩展，然后用刚刚的 vtable 对象（即类描述符）创建对象（因为刚刚创建的 vtable 包含了构造函数和对象大小）。因此创建对象要先创建类描述符。<br>因此对于成员和函数要有两个基类，vtable 因为只有一个且储存了对象大小信息所以叫 Class（为避免歧义称 Class 类为 vtable 类，或者叫类描述符类），而包括 vtable 类在内的所有类都继承自 Object 类，Object 类里面只有一个 Class 指针成员，表明所有对象都属于某个类。</p>\n</li>\n<li><p>还要静态创建 Class 和 Object 类的类描述符，用于子类的 ctor 和 dtor 中调用，初始化基类成员部分。对于 Object 的 ctor 什么都不用做， Class 的 ctor 初始化函数指针。</p>\n</li>\n<li><p>改进和个人思考：这里静态创建的 Class 和 Object 类的类描述符，用来作为 ctor 调父类 ctor 的终点，完成继承关系即 新类的 vtable -&gt; Class -&gt; Object 。新的类描述符要 new 出来，不如静态定义清晰，因为类不会像对象创建很多（虽然逻辑上确实是用 Class 这个 vtable 基类，创建新的类，相当于 new 新的类描述符对象，但这种对象不会很多）。如静态定义就不必再调 Class 的 ctor，也不必静态创建 Class 的类描述符。而且 Class 不必继承 Object，否则每个对象，成员部分继承 Object 有 Class 指针，函数部分也继承 Object，即 Class 部分还要有 Object，Object 里面又有 Class。Class 不继承 Object（即不包含 Object），自己本身就作为 vtable 形式的基类，与 Object 是平等的关系。新类的 ctor 没必要再调父类 Object 的 ctor，可以仅为了继承逻辑，struct Class Object &#x3D; {初始化}，新类指向 &amp;Object</p>\n  <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Object</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"type\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Class</span> * <span class=\"keyword\">class</span>;</span>\t<span class=\"comment\">// 没变化</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Class</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"comment\">// 这里去掉 Object 继承，const struct Object _;</span></span><br><span class=\"line\">\t<span class=\"type\">const</span> <span class=\"type\">char</span> * name;</span><br><span class=\"line\">\t<span class=\"type\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Class</span> * <span class=\"title\">super</span>;</span></span><br><span class=\"line\">\t<span class=\"type\">size_t</span> size;</span><br><span class=\"line\">\t<span class=\"type\">void</span> * (* ctor) (<span class=\"type\">void</span> * self, va_list * app);</span><br><span class=\"line\">\t<span class=\"type\">void</span> * (* dtor) (<span class=\"type\">void</span> * self);</span><br><span class=\"line\">\t<span class=\"type\">int</span> (* differ) (<span class=\"type\">const</span> <span class=\"type\">void</span> * self, <span class=\"type\">const</span> <span class=\"type\">void</span> * b);</span><br><span class=\"line\">\t<span class=\"type\">int</span> (* puto) (<span class=\"type\">const</span> <span class=\"type\">void</span> * self, FILE * fp);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Class</span> <span class=\"title\">Object</span> =</span> &#123;.name = <span class=\"string\">&quot;Object&quot;</span>&#125;; <span class=\"comment\">// 只定义 Object 的类描述符，不再定义 Class 的类描述符</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Point</span> &#123;</span></span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Object</span> _;</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> x, y;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">PointClass</span> &#123;</span>\t\t<span class=\"comment\">// 静态初始化类描述符</span></span><br><span class=\"line\">\t<span class=\"type\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Class</span> _;</span></span><br><span class=\"line\">\t<span class=\"type\">void</span> (* draw) (<span class=\"type\">const</span> <span class=\"type\">void</span> * self);</span><br><span class=\"line\">&#125; Point = &#123;_.name = <span class=\"string\">&quot;Point&quot;</span>, _.super = &amp;Object, _.size = <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">struct</span> Point), _.ctor = Point_ctor, .draw = Point_draw&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">p = new(Point, <span class=\"number\">1</span>, <span class=\"number\">2</span>);  <span class=\"comment\">// new 里面按照 Point 的大小申请内存和调构造函数</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>进一步举例如何应用</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">DeviceClass</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Class</span> <span class=\"title\">parent</span>;</span></span><br><span class=\"line\">    <span class=\"type\">void</span> (* fun1) (<span class=\"type\">const</span> <span class=\"type\">void</span> * self);</span><br><span class=\"line\">&#125; DeviceDesc = &#123;这个就是类描述符，创建对象时需要&#125; ;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Device</span> &#123;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Object</span> <span class=\"title\">parent</span>;</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> x, y;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">SubDeviceClass</span> &#123;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">DeviceClass</span> <span class=\"title\">parent</span>;</span></span><br><span class=\"line\">    <span class=\"type\">void</span> (* draw) (<span class=\"type\">const</span> <span class=\"type\">void</span> * self);</span><br><span class=\"line\">&#125; SubDeviceDesc = &#123;这里可以先继承父类的函数指针(.parent = DeviceDesc)，然后在后面来覆盖(.parent.parent.ctor = SubDeviceClass_ctor)，因为根据 C99 多次初始化最后那个有效&#125;;</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">SubDevice</span> &#123;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Device</span> <span class=\"title\">parent</span>;</span></span><br><span class=\"line\">    <span class=\"type\">int</span> z;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h1 id=\"4-异常处理\"><a href=\"#4-异常处理\" class=\"headerlink\" title=\"4 异常处理\"></a>4 异常处理</h1><p>用对应的库，用 setjmp 和 longjmp 实现。</p>\n<p>还能实现线程切换，已经放入 Dropbox 书 <a href=\"https://www.cs.princeton.edu/courses/archive/spring04/cos217/lectures/Exceptions.pdf\">https://www.cs.princeton.edu/courses/archive/spring04/cos217/lectures/Exceptions.pdf</a></p>\n<h1 id=\"5-单元测试\"><a href=\"#5-单元测试\" class=\"headerlink\" title=\"5 单元测试\"></a>5 单元测试</h1><p>试试 Google Test ？ <a href=\"https://stackoverflow.com/questions/65820/unit-testing-c-code\">https://stackoverflow.com/questions/65820/unit-testing-c-code</a></p>\n<h1 id=\"6-内存管理\"><a href=\"#6-内存管理\" class=\"headerlink\" title=\"6 内存管理\"></a>6 内存管理</h1><h1 id=\"7-安全\"><a href=\"#7-安全\" class=\"headerlink\" title=\"7 安全\"></a>7 安全</h1><p>cppcheck</p>\n",
            "tags": []
        }
    ]
}